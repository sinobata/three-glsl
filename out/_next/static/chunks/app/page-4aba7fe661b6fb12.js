(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[974],{2026:(n,e,o)=>{"use strict";o.d(e,{default:()=>g});var t=o(5155),r=o(2115),i=o(3816),a=o(7558),l=o(4932),c=o(3859),v=o(3264);let u=()=>({u_time:{value:0},u_resolution:{value:new v.I9Y(window.innerWidth,window.innerHeight)}});function s(n){let{position:e=[0,0,0],scale:o=[1,1,1]}=n,a=(0,r.useRef)([]);return(0,r.useMemo)(()=>{a.current=["precision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nconst float PI = 3.1415926;\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid main() {\n    // vUvを-1.0から1.0の範囲に正規化\n    vec2 uv = vUv * 2.0 - 1.0;\n\n    // サイコロの2の点を表示\n    float one = length(uv - vec2(-0.5, -0.5));\n    float two = length(uv - vec2(0.5, 0.5));\n\n    // 円の半径\n    float radius = 0.1;\n\n    // 円の内側を白、外側を黒に\n    float circle = step(one, radius) + step(two, radius);\n\n    vec2 rotateUv = uv * rotate2d(PI + u_time * 2.0);\n\n    // 対角線グラデーション背景色\n    float gradientFactor = (rotateUv.x + rotateUv.y + 2.0) / 4.0;\n\n    // グラデーションの色を定義\n    vec3 color1 = vec3(0.0, 0.0, 1.0); // 左下の色（青）\n    vec3 color2 = vec3(1.0, 0.0, 0.0); // 右上の色（赤）\n\n    vec3 backgroundColor = mix(color1, color2, gradientFactor);\n\n    vec3 dotColor = vec3(0.0, 0.0, 0.0);\n\n    vec3 color = mix(backgroundColor, dotColor, circle);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n","precision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nvoid main() {\n    // vUvを-1.0から1.0の範囲に正規化\n    vec2 uv = vUv * 2.0 - 1.0;\n\n    // サイコロの5の点を表示\n    float one = length(uv - vec2(-0.5, -0.5));\n    float two = length(uv - vec2(0.5, -0.5));\n    float three = length(uv - vec2(-0.5, 0.5));\n    float four = length(uv - vec2(0.5, 0.5));\n    float five = length(uv - vec2(0.0, 0.0));\n\n    // 円の半径\n    float radius = 0.1;\n\n    // 円の内側を白、外側を黒に\n    float circle =\n        step(one, radius) +\n        step(two, radius) +\n        step(three, radius) +\n        step(four, radius) +\n        step(five, radius);\n\n    // 背景色と点の色（黒）を混合\n    float background = 0.03 / abs(tan(u_time * 4.0) - length(uv));\n\n    vec3 dotColor = vec3(0.0, 0.0, 0.0);\n\n    vec3 color = mix(\n        vec3(mix(vec3(0.9), vec3(0.0), background)),\n        dotColor,\n        circle\n    );\n\n    gl_FragColor = vec4(color, 1.0);\n}\n","precision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nconst float PI = 3.1415926;\nvec3 hsb2rgb(vec3 c) {\n    vec3 rgb = clamp(\n        abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0,\n        1.0\n    );\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    // vUvを-1.0から1.0の範囲に正規化\n    vec2 uv = vUv * 2.0 - 1.0;\n\n    // サイコロの3の点を表示\n    float one = length(uv - vec2(-0.5, -0.5));\n    float two = length(uv - vec2(0.0, 0.0));\n    float three = length(uv - vec2(0.5, 0.5));\n\n    // 円の半径\n    float radius = 0.1;\n\n    // 円の内側を白、外側を黒に\n    float circle = step(one, radius) + step(two, radius) + step(three, radius);\n\n    // 背景色\n    vec3 backgroundColor = hsb2rgb(\n        vec3((atan(uv.y, uv.x) + PI) / (PI * 2.0) + u_time * 0.2, 1.0, 1.0)\n    );\n\n    // 点の色（黒）\n    vec3 dotColor = vec3(0.0, 0.0, 0.0);\n    vec3 color = mix(backgroundColor, dotColor, circle);\n    gl_FragColor = vec4(color, 1.0);\n}\n","precision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nvoid main() {\n    // vUvを-1.0から1.0の範囲に正規化\n    vec2 uv = vUv * 2.0 - 1.0;\n\n    // サイコロの4の点を表示\n    float one = length(uv - vec2(-0.4, -0.4));\n    float two = length(uv - vec2(0.4, -0.4));\n    float three = length(uv - vec2(-0.4, 0.4));\n    float four = length(uv - vec2(0.4, 0.4));\n\n    // 円の半径\n    float radius = 0.1;\n\n    // 円の内側を白、外側を黒に\n    float circle =\n        step(one, radius) +\n        step(two, radius) +\n        step(three, radius) +\n        step(four, radius);\n\n    // ジグザグの線を表示\n    // X軸方向のジグザグライン（水平）\n    float zigzagX = asin(sin(uv.x * 20.0)) * 0.05;\n    float revertX = 0.25 / (100.0 * abs(uv.y - zigzagX)) * 1.2;\n\n    // Y軸方向のsin波\n    float zigzagY = sin(uv.y * 20.0 - 3.0) * 0.05;\n    float revertY = 0.25 / (100.0 * abs(uv.x - zigzagY)) * 1.2;\n\n    // 両方のラインを合成\n    float combinedEffect = max(revertX, revertY);\n\n    vec3 backgroundColor = mix(\n        vec3(0.9, 0.9, 0.9),\n        vec3(0.0, 0.0, 0.0),\n        combinedEffect\n    );\n\n    vec3 dotColor = vec3(0.0, 0.0, 0.0);\n    vec3 color = mix(backgroundColor, dotColor, circle);\n    gl_FragColor = vec4(color, 1.0);\n}\n","precision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nconst float PI = 3.1415926;\nconst vec3 lightColor = vec3(0.9, 0.9, 0.5); // 背景の後光の色\nconst vec3 backColor = vec3(0.9, 0.3, 0.3); // 背景の下地の色\n\n// 背景の後光を描く\nvoid sunrise(vec2 uv, inout vec3 i) {\n    float f = atan(uv.y, uv.x) + u_time;\n    float fs = sin(f * 6.0);\n    i = mix(lightColor, backColor, fs);\n}\n\nvoid main() {\n    // vUvを-1.0から1.0の範囲に正規化\n    vec2 uv = vUv * 2.0 - 1.0;\n\n    // サイコロの1の点を表示\n    float dist = length(uv - vec2(0.0, 0.0));\n\n    // 円の半径\n    float radius = 0.2;\n\n    // 円の内側を白、外側を黒に\n    float circle = step(dist, radius);\n\n    // 背景色\n    vec3 backgroundColor = vec3(0.9, 0.9, 0.9);\n    // 背景の後光を描く\n    sunrise(uv, backgroundColor);\n\n    vec3 dotColor = backColor;\n    // 背景色と点の色（赤）を混合\n    vec3 color = mix(backgroundColor, dotColor, circle);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n","precision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    // vUvを-1.0から1.0の範囲に正規化\n    vec2 uv = vUv * 2.0 - 1.0;\n\n    // 時間ベースのランダム値\n    float timeRand = rand(vec2(floor(u_time * 2.0), 0.0));\n    float timeRand2 = rand(vec2(floor(u_time * 3.0), 1.0));\n\n    // グリッチの強度をランダムに変化\n    float glitchIntensity1 = pow(1.0 - fract(u_time), 16.0);\n    float glitchIntensity2 = pow(1.0 - fract(u_time + 0.3), 12.0);\n    float glitchIntensity3 = pow(1.0 - fract(u_time + 0.7), 8.0);\n\n    // ランダムに動く場所を決定\n    if (timeRand > 0.3) {\n        // 水平方向のグリッチ（Y軸方向の線）\n        uv.x +=\n            rand(vec2(floor(uv.y * 30.0 + u_time), 0.0)) *\n            glitchIntensity1 *\n            1.3;\n    }\n\n    if (timeRand2 > 0.4) {\n        // 垂直方向のグリッチ（X軸方向の線）\n        uv.y +=\n            rand(vec2(floor(uv.x * 25.0 + u_time * 1.5), 1.0)) *\n            glitchIntensity2 *\n            0.8;\n    }\n\n    // 斜め方向のグリッチ\n    if (timeRand2 > 0.7) {\n        float diagonalGlitch = rand(\n            vec2(floor((uv.x + uv.y) * 15.0 + u_time * 2.5), 2.0)\n        );\n        if (diagonalGlitch > 0.8) {\n            uv.x += (diagonalGlitch - 0.5) * glitchIntensity1 * 1.0;\n            uv.y +=\n                (rand(vec2(diagonalGlitch, u_time)) - 0.5) *\n                glitchIntensity2 *\n                0.6;\n        }\n    }\n\n    // 細かいノイズ\n    if (timeRand > 0.5) {\n        uv.x +=\n            rand(vec2(floor(uv.x * 50.0 + u_time * 4.0), 3.0)) *\n            glitchIntensity3 *\n            0.3;\n    }\n\n    // サイコロの6の点を表示\n    float one = length(uv - vec2(-0.4, -0.4));\n    float two = length(uv - vec2(-0.4, 0.4));\n    float three = length(uv - vec2(-0.4, 0.0));\n    float four = length(uv - vec2(0.4, 0.4));\n    float five = length(uv - vec2(0.4, -0.4));\n    float six = length(uv - vec2(0.4, 0.0));\n\n    // 円の半径\n    float radius = 0.1;\n\n    // 円の内側を白、外側を黒に\n    float circle =\n        step(one, radius) +\n        step(two, radius) +\n        step(three, radius) +\n        step(four, radius) +\n        step(five, radius) +\n        step(six, radius);\n\n    // 背景色と点の色（黒）を混合\n    vec3 backgroundColor = vec3(0.9, 0.9, 0.9);\n\n    vec3 dotColor = vec3(0.0, 0.0, 0.0);\n\n    vec3 color = mix(backgroundColor, dotColor, circle);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n"].map(n=>new v.BKk({vertexShader:"precision mediump float;\n\n// Three.jsが自動的に提供する変数：\n// attribute vec3 position;\n// attribute vec2 uv;\n// attribute vec3 normal;\n// uniform mat4 projectionMatrix;\n// uniform mat4 modelViewMatrix;\n// uniform mat3 normalMatrix;\n\nuniform float u_time;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nvoid main() {\n    vUv = uv;\n    vNormal = normalize(normalMatrix * normal);\n    vPosition = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:n,uniforms:u(),side:v.$EB}))},[]),(0,i.C)(n=>{a.current.forEach(e=>{(null==e?void 0:e.uniforms.u_time)&&(e.uniforms.u_time.value=n.clock.elapsedTime)})}),(0,t.jsx)("mesh",{position:e,scale:o,material:a.current,children:(0,t.jsx)("boxGeometry",{args:[2,2,2]})})}let d={1:new v.Pq0(0,0,5),2:new v.Pq0(5,0,0),3:new v.Pq0(0,5,0),4:new v.Pq0(0,-5,0),5:new v.Pq0(-5,0,0),6:new v.Pq0(0,0,-5)};function f(n){let{targetPosition:e,isAnimating:o,onAnimationComplete:t}=n,{camera:a}=(0,i.A)(),l=(0,r.useRef)(new v.Pq0),c=(0,r.useRef)(new v.Pq0);return(0,r.useEffect)(()=>{o&&(l.current.copy(a.position),c.current.copy(e))},[e,a,o]),(0,i.C)(()=>{o&&(l.current.lerp(c.current,.08),a.position.copy(l.current),a.lookAt(0,0,0),.1>l.current.distanceTo(c.current)&&(a.position.copy(c.current),t()))}),null}function m(n){let{onFaceChange:e}=n;return(0,r.useEffect)(()=>{let n=n=>{let o=n.key;o>="1"&&o<="6"&&e(parseInt(o))};return window.addEventListener("keydown",n),()=>window.removeEventListener("keydown",n)},[e]),null}function g(){let[n,e]=(0,r.useState)(1),[o,i]=(0,r.useState)(d[1]),[v,u]=(0,r.useState)(!1),g=(0,r.useRef)(null),p=n=>{e(n),i(d[n]),u(!0),g.current&&(g.current.enabled=!1)};return(0,t.jsxs)("div",{className:"w-full h-screen relative",children:[(0,t.jsxs)("div",{className:"absolute top-4 left-4 z-10 bg-black bg-opacity-50 text-white p-4 rounded",children:[(0,t.jsx)("h3",{className:"text-lg font-bold mb-2",children:"カメラ制御"}),(0,t.jsx)("p",{className:"text-sm mb-2",children:"キーボード: 1-6でサイコロの面を切り替え"}),(0,t.jsx)("p",{className:"text-sm mb-2",children:"マウス: ドラッグで自由に回転"}),(0,t.jsxs)("p",{className:"text-sm mb-4",children:["現在の面: ",n," ",v?"(移動中...)":""]}),(0,t.jsx)("div",{className:"grid grid-cols-3 gap-2",children:[1,2,3,4,5,6].map(e=>(0,t.jsx)("button",{onClick:()=>p(e),disabled:v,className:"px-3 py-2 rounded text-sm font-bold transition-colors ".concat(n===e?"bg-blue-500 text-white":v?"bg-gray-800 text-gray-500 cursor-not-allowed":"bg-gray-700 text-gray-300 hover:bg-gray-600"),children:e},e))})]}),(0,t.jsxs)(a.Hl,{camera:{position:[0,0,5],fov:75},gl:{antialias:!0,alpha:!0},dpr:[1,2],children:[(0,t.jsx)("ambientLight",{intensity:.5}),(0,t.jsx)("directionalLight",{position:[10,10,5],intensity:1}),(0,t.jsx)(r.Suspense,{fallback:null,children:(0,t.jsx)(s,{position:[0,0,0],scale:[1,1,1]})}),(0,t.jsx)(f,{targetPosition:o,isAnimating:v,onAnimationComplete:()=>{u(!1),g.current&&(g.current.enabled=!0)}}),(0,t.jsx)(l.N,{ref:g,enablePan:!0,enableZoom:!0,enableRotate:!0,target:[0,0,0],enableDamping:!0,dampingFactor:.05}),(0,t.jsx)(m,{onFaceChange:p}),(0,t.jsx)(c.U,{})]})]})}},8858:(n,e,o)=>{Promise.resolve().then(o.bind(o,2026))}},n=>{var e=e=>n(n.s=e);n.O(0,[367,831,413,796,441,684,358],()=>e(8858)),_N_E=n.O()}]);